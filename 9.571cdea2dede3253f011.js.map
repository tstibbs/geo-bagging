{"version":3,"sources":["webpack:///./test/conversion_test.js","webpack:///./src/js/conversion.js"],"names":["assertCloseEnough","assert","gridRef","lon","lat","leeway","actualValue","gridRefToLngLat","equal","length","assertNear","actual","expected","lower","Math","floor","upper","ceil","ok","describe","it","latLngToGridRef","osgbToLngLat","deepEqual","gridRefToOsgb","throws","osgbProj","pad","num","w","n","toString","lng","digits","out","forward","eastings","northings","undefined","Number","isNaN","Error","e","e100k","n100k","l1","l2","letPair","String","fromCharCode","charCodeAt","pow","inverse","gridref","trim","this","_determineGridRefType","match","OsGridRef","toUpperCase","e100km","n100km","en","slice","split","parseInt","lngLat","test"],"mappings":"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","file":"9.571cdea2dede3253f011.js","sourcesContent":["import {assert} from 'chai'\n\nimport conversion from '../src/js/conversion'\n\ndescribe('conversion', function () {\n\tit('latLngToGridRef - should return actual grid refs', function () {\n\t\tassert.equal(conversion.latLngToGridRef(52.657977, 1.716038), 'TG 51408 13177')\n\t})\n\n\tit('osgbToLngLat - should work for valid OSBGs', function () {\n\t\tvar actualValue = conversion.osgbToLngLat(651409, 313177) // array is long, lat\n\t\tassert.equal(actualValue.length, 2)\n\t\tassertNear(assert, actualValue[0], 1.7160384428258, 0)\n\t\tassertNear(assert, actualValue[1], 52.657976601295, 0)\n\t})\n\n\tit('gridRefToOsgb - should work for valid grid refs', function () {\n\t\tassert.deepEqual(conversion.gridRefToOsgb('TG 51408 13177'), [651408, 313177]) // array is long, lat\n\t})\n\tit('gridRefToOsgb - should work for channel islands', function () {\n\t\tassert.deepEqual(conversion.gridRefToOsgb('XD  83873  22339'), [383873, -77661]) // array is long, lat\n\t})\n\n\tit('gridRefToLngLat - should work for valid grid refs', function () {\n\t\tassertCloseEnough(assert, 'TG 51408 13177', 1.716023690108, 52.657977064472, 0)\n\t})\n\n\tit('gridRefToOsgb - should error for irish grids', function () {\n\t\tassert.throws(function () {\n\t\t\tconversion.gridRefToOsgb('S  6797  3789')\n\t\t}, /Irish/)\n\t\tassert.throws(function () {\n\t\t\tconversion.gridRefToOsgb('W328850')\n\t\t}, /Irish/)\n\t})\n\n\tit('gridRefToLngLat - should work for ireland and channel islands', function () {\n\t\tassertCloseEnough(assert, 'MZ 82568 85820', -8.53034, 54.99125, 0.00002)\n\t\tassertCloseEnough(assert, 'MZ 86383 16308', -8.37269, 54.37367, 0.00002)\n\t\tassertCloseEnough(assert, 'RE 09504 80322', -9.48801, 53.98501, 0.00002)\n\t\tassertCloseEnough(assert, 'RO 61800 27500', -9.79229, 51.68706, 0.00002)\n\t\tassertCloseEnough(assert, 'WA 55943 05921', -13.43272, 48.48317, 0.0001) //there's a different ellipsis that we need to use for the channel islands, but this is close enough for now\n\t\tassertCloseEnough(assert, 'WA 57817 06737', -13.40949, 48.49285, 0.0001) //there's a different ellipsis that we need to use for the channel islands, but this is close enough for now\n\t})\n})\n\nfunction assertCloseEnough(assert, gridRef, lon, lat, leeway) {\n\tvar actualValue = conversion.gridRefToLngLat(gridRef) // array is long, lat\n\tassert.equal(actualValue.length, 2)\n\tassertNear(assert, actualValue[0], lon, leeway)\n\tassertNear(assert, actualValue[1], lat, leeway)\n}\n\n// The exact results seem to change slightly from browser to browser, and even between different versions of node.\n// However, the 5th decimal place is about 1 metre at our latitude/longitude, so we _really_ don't need to care about small differences\nfunction assertNear(assert, actual, expected, leeway) {\n\tvar rounder = 100000\n\tvar lower = Math.floor(expected * rounder) / rounder\n\tvar upper = Math.ceil(expected * rounder) / rounder\n\tlower -= leeway\n\tupper += leeway\n\n\tassert.ok(actual >= lower, actual + ' should be >= ' + lower)\n\tassert.ok(actual <= upper, actual + ' should be <= ' + upper)\n}\n","//heavily borrowed from www.movable-type.co.uk/scripts/latlong-gridref.html (MIT licence)\nimport proj4 from 'proj4'\n\nvar osgbProj = proj4(\n\t'+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs'\n)\n\nfunction pad(num, w) {\n\tvar n = num.toString()\n\twhile (n.length < w) n = '0' + n\n\treturn n\n}\n\nexport default {\n\tlatLngToGridRef: function (lat, lng) {\n\t\tvar digits = 10\n\n\t\tvar out = osgbProj.forward([lng, lat]) //from WSG84\n\t\tvar eastings = out[0]\n\t\tvar northings = out[1]\n\n\t\tdigits = digits === undefined ? 10 : Number(digits)\n\t\tif (isNaN(digits)) throw new Error('Invalid precision')\n\n\t\tvar e = Number(Number(eastings))\n\t\tvar n = Number(Number(northings))\n\n\t\tif (isNaN(e) || isNaN(n)) throw new Error('Invalid grid reference: ' + [lat, lng])\n\n\t\t// use digits = 0 to return numeric format (in metres)\n\t\tif (digits === 0) return pad(e, 6) + ',' + pad(n, 6)\n\n\t\t// get the 100km-grid indices\n\t\tvar e100k = Math.floor(e / 100000),\n\t\t\tn100k = Math.floor(n / 100000)\n\n\t\tif (e100k < 0 || e100k > 6 || n100k < 0 || n100k > 12) return ''\n\n\t\t// translate those into numeric equivalents of the grid letters\n\t\tvar l1 = 19 - n100k - ((19 - n100k) % 5) + Math.floor((e100k + 10) / 5)\n\t\tvar l2 = (((19 - n100k) * 5) % 25) + (e100k % 5)\n\n\t\t// compensate for skipped 'I' and build grid letter-pairs\n\t\tif (l1 > 7) l1++\n\t\tif (l2 > 7) l2++\n\t\tvar letPair = String.fromCharCode(l1 + 'A'.charCodeAt(0), l2 + 'A'.charCodeAt(0))\n\n\t\t// strip 100km-grid indices from easting & northing, and reduce precision\n\t\te = Math.floor((e % 100000) / Math.pow(10, 5 - digits / 2))\n\t\tn = Math.floor((n % 100000) / Math.pow(10, 5 - digits / 2))\n\n\t\tvar gridRef = letPair + ' ' + pad(e, digits / 2) + ' ' + pad(n, digits / 2)\n\n\t\treturn gridRef\n\t},\n\n\tosgbToLngLat: function (eastings, northings) {\n\t\tvar out = osgbProj.inverse([eastings, northings]) //to WSG84\n\t\treturn out\n\t},\n\n\tgridRefToOsgb: function (/*String*/ gridref) {\n\t\tgridref = String(gridref).trim()\n\t\tthis._determineGridRefType(gridref)\n\n\t\t// check for fully numeric comma-separated gridref format\n\t\tvar match = gridref.match(/^(\\d+),\\s*(\\d+)$/)\n\t\tif (match) return new OsGridRef(match[1], match[2])\n\n\t\t// validate format\n\t\tmatch = gridref.match(/^[A-Z]{2}\\s*[0-9]+\\s*[0-9]+$/i)\n\t\tif (!match) throw new Error('Invalid grid reference: ' + gridref)\n\n\t\t// get numeric values of letter references, mapping A->0, B->1, C->2, etc:\n\t\tvar l1 = gridref.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0)\n\t\tvar l2 = gridref.toUpperCase().charCodeAt(1) - 'A'.charCodeAt(0)\n\t\t// shuffle down letters after 'I' since 'I' is not used in grid:\n\t\tif (l1 > 7) l1--\n\t\tif (l2 > 7) l2--\n\n\t\t// convert grid letters into 100km-square indexes from false origin (grid square SV):\n\t\tvar e100km = ((l1 - 2) % 5) * 5 + (l2 % 5)\n\t\tvar n100km = 19 - Math.floor(l1 / 5) * 5 - Math.floor(l2 / 5)\n\n\t\t// skip grid letters to get numeric (easting/northing) part of ref\n\t\tvar en = gridref.slice(2).trim().split(/\\s+/)\n\t\t// if e/n not whitespace separated, split half way\n\t\tif (en.length == 1) en = [en[0].slice(0, en[0].length / 2), en[0].slice(en[0].length / 2)]\n\n\t\t//fix for grid refs technically part of the grid but outside of the uk\n\t\t//this helped to work this out: https://raw.githubusercontent.com/wu-lee/dinty/master/national-grid.png\n\t\tif (e100km >= 15) {\n\t\t\te100km -= 25\n\t\t}\n\t\tif (n100km > 20) {\n\t\t\tn100km -= 25\n\t\t}\n\n\t\t// validation\n\t\tif (e100km < -10 || n100km < -5)\n\t\t\tthrow new Error('Invalid grid reference: gridref=' + gridref + ', e100km=' + e100km + ', n100km=' + n100km)\n\t\tif (en.length != 2) throw new Error('Invalid grid reference: ' + gridref)\n\t\tif (en[0].length != en[1].length) throw new Error('Invalid grid reference: ' + gridref)\n\n\t\t// standardise to 10-digit refs (metres)\n\t\ten[0] = (en[0] + '00000').slice(0, 5)\n\t\ten[1] = (en[1] + '00000').slice(0, 5)\n\n\t\tvar e = parseInt(e100km + '00000') + parseInt(en[0])\n\t\tvar n = parseInt(n100km + '00000') + parseInt(en[1])\n\n\t\treturn [e, n]\n\t},\n\n\tgridRefToLngLat: function (/*String*/ gridref) {\n\t\tvar lngLat = this.gridRefToOsgb(gridref)\n\t\tvar out = osgbProj.inverse(lngLat) //to WSG84\n\t\treturn out\n\t},\n\n\t_determineGridRefType: function (gridref) {\n\t\tif (/^\\w\\s*\\d{3,}\\s*\\d{3,}$/.test(gridref)) {\n\t\t\tthrow new Error('Irish grid references currently unsupported: ' + gridref)\n\t\t}\n\t}\n}\n"],"sourceRoot":""}