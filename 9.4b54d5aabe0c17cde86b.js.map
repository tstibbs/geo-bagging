{"version":3,"sources":["webpack:///./test/conversion_test.js","webpack:///./src/js/conversion.js"],"names":["assertCloseEnough","assert","gridRef","lon","lat","leeway","actualValue","gridRefToLngLat","equal","length","assertNear","actual","expected","lower","Math","floor","upper","ceil","ok","describe","it","latLngToGridRef","osgbToLngLat","deepEqual","gridRefToOsgb","throws","osgbProj","pad","num","w","n","toString","lng","digits","out","forward","eastings","northings","undefined","Number","isNaN","Error","e","e100k","n100k","l1","l2","letPair","String","fromCharCode","charCodeAt","pow","inverse","gridref","trim","this","_determineGridRefType","match","OsGridRef","toUpperCase","e100km","n100km","en","slice","split","parseInt","lngLat","test"],"mappings":"6FAAA,mCAoDA,SAASA,EAAkBC,EAAQC,EAASC,EAAKC,EAAKC,GAClD,IAAIC,EAAc,IAAWC,gBAAgBL,GAC7CD,EAAOO,MAAMF,EAAYG,OAAQ,GACjCC,EAAWT,EAAQK,EAAY,GAAIH,EAAKE,GACxCK,EAAWT,EAAQK,EAAY,GAAIF,EAAKC,GAK5C,SAASK,EAAWT,EAAQU,EAAQC,EAAUP,GAC1C,IACIQ,EAAQC,KAAKC,MADH,IACSH,GADT,IAEVI,EAAQF,KAAKG,KAFH,IAEQL,GAFR,IAGdC,GAASR,EACTW,GAASX,EAETJ,EAAOiB,GAAGP,GAAUE,EAAOF,EAAS,iBAAmBE,GACvDZ,EAAOiB,GAAGP,GAAUK,EAAOL,EAAS,iBAAmBK,GAjE3DG,SAAS,cAAc,WACnBC,GAAG,oDAAoD,WACnD,SAAOZ,MAAM,IAAWa,gBAAgB,UAAW,UAAW,qBAGlED,GAAG,8CAA8C,WAC7C,IAAId,EAAc,IAAWgB,aAAa,OAAQ,QAClD,SAAOd,MAAMF,EAAYG,OAAQ,GACjCC,EAAW,SAAQJ,EAAY,GAAI,gBAAiB,GACpDI,EAAW,SAAQJ,EAAY,GAAI,gBAAiB,MAGxDc,GAAG,mDAAmD,WAClD,SAAOG,UAAU,IAAWC,cAAc,kBAAmB,CAAC,OAAQ,YAE1EJ,GAAG,mDAAmD,WAClD,SAAOG,UAAU,IAAWC,cAAc,oBAAqB,CAAC,QAAS,WAG7EJ,GAAG,qDAAqD,WACpDpB,EAAkB,SAAQ,iBAAkB,eAAkB,gBAAiB,MAGnFoB,GAAG,gDAAgD,WAC/C,SAAOK,QACH,WACI,IAAWD,cAAc,mBAE7B,SAEJ,SAAOC,QACH,WACI,IAAWD,cAAc,aAE7B,YAIRJ,GAAG,iEAAiE,WAChEpB,EAAkB,SAAQ,kBAAmB,QAAS,SAAU,MAChEA,EAAkB,SAAQ,kBAAmB,QAAS,SAAU,MAChEA,EAAkB,SAAQ,kBAAmB,QAAS,SAAU,MAChEA,EAAkB,SAAQ,kBAAmB,QAAS,SAAU,MAChEA,EAAkB,SAAQ,kBAAmB,SAAU,SAAU,MACjEA,EAAkB,SAAQ,kBAAmB,SAAU,SAAU,a,kCChDzE,gBAGI0B,EAAW,YAAM,wHAErB,SAASC,EAAIC,EAAKC,GAEjB,IADA,IAAIC,EAAIF,EAAIG,WACLD,EAAErB,OAASoB,GAAGC,EAAI,IAAMA,EAC/B,OAAOA,EAGO,KACdT,gBAAiB,SAASjB,EAAK4B,GAE9B,IAAIC,EAAS,GAETC,EAAMR,EAASS,QAAQ,CAACH,EAAK5B,IAC7BgC,EAAWF,EAAI,GACfG,EAAYH,EAAI,GAGpB,GADAD,OAAqBK,IAAXL,EAAwB,GAAKM,OAAON,GAC1CO,MAAMP,GAAS,MAAM,IAAIQ,MAAM,qBAEnC,IAAIC,EAAIH,OAAOA,OAAOH,IAClBN,EAAIS,OAAOA,OAAOF,IAEtB,GAAIG,MAAME,IAAMF,MAAMV,GAAI,MAAM,IAAIW,MAAM,2BAA6B,CAACrC,EAAK4B,IAG7E,GAAe,IAAXC,EAAc,OAAON,EAAIe,EAAG,GAAG,IAAIf,EAAIG,EAAG,GAG9C,IAAIa,EAAQ7B,KAAKC,MAAM2B,EAAE,KAASE,EAAQ9B,KAAKC,MAAMe,EAAE,KAEvD,GAAIa,EAAM,GAAKA,EAAM,GAAKC,EAAM,GAAKA,EAAM,GAAI,MAAO,GAGtD,IAAIC,EAAM,GAAGD,GAAU,GAAGA,GAAO,EAAI9B,KAAKC,OAAO4B,EAAM,IAAI,GACvDG,EAAgB,GAAV,GAAGF,GAAS,GAAKD,EAAM,EAG7BE,EAAK,GAAGA,IACRC,EAAK,GAAGA,IACZ,IAAIC,EAAUC,OAAOC,aAAaJ,EAAG,IAAIK,WAAW,GAAIJ,EAAG,IAAII,WAAW,IAQ1E,OALAR,EAAI5B,KAAKC,MAAO2B,EAAE,IAAQ5B,KAAKqC,IAAI,GAAI,EAAElB,EAAO,IAChDH,EAAIhB,KAAKC,MAAOe,EAAE,IAAQhB,KAAKqC,IAAI,GAAI,EAAElB,EAAO,IAElCc,EAAU,IAAMpB,EAAIe,EAAGT,EAAO,GAAK,IAAMN,EAAIG,EAAGG,EAAO,IAKtEX,aAAc,SAASc,EAAUC,GAEhC,OADUX,EAAS0B,QAAQ,CAAChB,EAAUC,KAIvCb,cAAe,SAAoB6B,GAClCA,EAAUL,OAAOK,GAASC,OAC1BC,KAAKC,sBAAsBH,GAG3B,IAAII,EAAQJ,EAAQI,MAAM,oBAC1B,GAAIA,EAAO,OAAO,IAAIC,UAAUD,EAAM,GAAIA,EAAM,IAIhD,KADAA,EAAQJ,EAAQI,MAAM,kCACV,MAAM,IAAIhB,MAAM,2BAA6BY,GAGzD,IAAIR,EAAKQ,EAAQM,cAAcT,WAAW,GAAK,IAAIA,WAAW,GAC1DJ,EAAKO,EAAQM,cAAcT,WAAW,GAAK,IAAIA,WAAW,GAE1DL,EAAK,GAAGA,IACRC,EAAK,GAAGA,IAGZ,IAAIc,GAAWf,EAAG,GAAG,EAAG,EAAKC,EAAG,EAC5Be,EAAU,GAAoB,EAAjB/C,KAAKC,MAAM8B,EAAG,GAAQ/B,KAAKC,MAAM+B,EAAG,GAGjDgB,EAAKT,EAAQU,MAAM,GAAGT,OAAOU,MAAM,OAcvC,GAZiB,GAAbF,EAAGrD,SAAaqD,EAAK,CAAEA,EAAG,GAAGC,MAAM,EAAGD,EAAG,GAAGrD,OAAO,GAAIqD,EAAG,GAAGC,MAAMD,EAAG,GAAGrD,OAAO,KAIhFmD,GAAU,KACbA,GAAU,IAEPC,EAAS,KACZA,GAAU,IAIPD,GAAU,IAAMC,GAAU,EAAI,MAAM,IAAIpB,MAAM,mCAAmCY,EAAQ,YAAYO,EAAO,YAAYC,GAC5H,GAAiB,GAAbC,EAAGrD,OAAa,MAAM,IAAIgC,MAAM,2BAA6BY,GACjE,GAAIS,EAAG,GAAGrD,QAAUqD,EAAG,GAAGrD,OAAQ,MAAM,IAAIgC,MAAM,2BAA6BY,GAS/E,OANAS,EAAG,IAAMA,EAAG,GAAG,SAASC,MAAM,EAAG,GACjCD,EAAG,IAAMA,EAAG,GAAG,SAASC,MAAM,EAAG,GAK1B,CAHCE,SAASL,EAAS,SAAWK,SAASH,EAAG,IACzCG,SAASJ,EAAS,SAAWI,SAASH,EAAG,MAKlDvD,gBAAiB,SAAoB8C,GACpC,IAAIa,EAASX,KAAK/B,cAAc6B,GAEhC,OADU3B,EAAS0B,QAAQc,IAI5BV,sBAAuB,SAASH,GAC/B,GAAI,yBAAyBc,KAAKd,GACjC,MAAM,IAAIZ,MAAM,gDAAkDY","file":"9.4b54d5aabe0c17cde86b.js","sourcesContent":["import {assert} from 'chai'\n\nimport conversion from \"../src/js/conversion\";\n\ndescribe('conversion', function() {\n    it('latLngToGridRef - should return actual grid refs', function() {\n        assert.equal(conversion.latLngToGridRef(52.657977, 1.716038), 'TG 51408 13177');\n    });\n\n    it('osgbToLngLat - should work for valid OSBGs', function() {\n        var actualValue = conversion.osgbToLngLat(651409, 313177); // array is long, lat\n        assert.equal(actualValue.length, 2);\n        assertNear(assert, actualValue[0], 1.7160384428258, 0);\n        assertNear(assert, actualValue[1], 52.657976601295, 0);\n    });\n\n    it('gridRefToOsgb - should work for valid grid refs', function() {\n        assert.deepEqual(conversion.gridRefToOsgb('TG 51408 13177'), [651408, 313177]); // array is long, lat\n    });\n    it('gridRefToOsgb - should work for channel islands', function() {\n        assert.deepEqual(conversion.gridRefToOsgb('XD  83873  22339'), [383873, -77661]); // array is long, lat\n    });\n\n    it('gridRefToLngLat - should work for valid grid refs', function() {\n        assertCloseEnough(assert, 'TG 51408 13177', 1.71602369010800, 52.657977064472, 0);\n    });\n\n    it('gridRefToOsgb - should error for irish grids', function() {\n        assert.throws(\n            function() {\n                conversion.gridRefToOsgb('S  6797  3789');\n            },\n            /Irish/\n        );\n        assert.throws(\n            function() {\n                conversion.gridRefToOsgb('W328850');\n            },\n            /Irish/\n        );\n    });\n\n    it('gridRefToLngLat - should work for ireland and channel islands', function() {\n        assertCloseEnough(assert, 'MZ 82568 85820', -8.53034, 54.99125, 0.00002);\n        assertCloseEnough(assert, 'MZ 86383 16308', -8.37269, 54.37367, 0.00002);\n        assertCloseEnough(assert, 'RE 09504 80322', -9.48801, 53.98501, 0.00002);\n        assertCloseEnough(assert, 'RO 61800 27500', -9.79229, 51.68706, 0.00002);\n        assertCloseEnough(assert, 'WA 55943 05921', -13.43272, 48.48317, 0.0001); //there's a different ellipsis that we need to use for the channel islands, but this is close enough for now\n        assertCloseEnough(assert, 'WA 57817 06737', -13.40949, 48.49285, 0.0001); //there's a different ellipsis that we need to use for the channel islands, but this is close enough for now\n    });\n});\n\nfunction assertCloseEnough(assert, gridRef, lon, lat, leeway) {\n    var actualValue = conversion.gridRefToLngLat(gridRef); // array is long, lat\n    assert.equal(actualValue.length, 2);\n    assertNear(assert, actualValue[0], lon, leeway);\n    assertNear(assert, actualValue[1], lat, leeway);\n}\n\n// The exact results seem to change slightly from browser to browser, and even between different versions of node.\n// However, the 5th decimal place is about 1 metre at our latitude/longitude, so we _really_ don't need to care about small differences\nfunction assertNear(assert, actual, expected, leeway) {\n    var rounder = 100000;\n    var lower = Math.floor(expected * rounder) / rounder;\n    var upper = Math.ceil(expected * rounder) / rounder;\n    lower -= leeway;\n    upper += leeway;\n\n    assert.ok(actual >= lower, actual + \" should be >= \" + lower);\n    assert.ok(actual <= upper, actual + \" should be <= \" + upper);\n}\n","//heavily borrowed from www.movable-type.co.uk/scripts/latlong-gridref.html (MIT licence)\nimport proj4 from \"proj4\";\n\t\t\nvar osgbProj = proj4(\"+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs\");\n\nfunction pad(num, w) {\n\tvar n = num.toString();\n\twhile (n.length < w) n = '0' + n;\n\treturn n;\n}\n\nexport default {\n\tlatLngToGridRef: function(lat, lng) {\n\n\t\tvar digits = 10;\n\t\t\n\t\tvar out = osgbProj.forward([lng, lat]);//from WSG84\n\t\tvar eastings = out[0];\n\t\tvar northings = out[1];\n\n\t\tdigits = (digits === undefined) ? 10 : Number(digits);\n\t\tif (isNaN(digits)) throw new Error('Invalid precision');\n\n\t\tvar e = Number(Number(eastings));\n\t\tvar n = Number(Number(northings));\n\n\t\tif (isNaN(e) || isNaN(n)) throw new Error('Invalid grid reference: ' + [lat, lng]);\n\n\t\t// use digits = 0 to return numeric format (in metres)\n\t\tif (digits === 0) return pad(e, 6)+','+pad(n, 6);\n\n\t\t// get the 100km-grid indices\n\t\tvar e100k = Math.floor(e/100000), n100k = Math.floor(n/100000);\n\n\t\tif (e100k<0 || e100k>6 || n100k<0 || n100k>12) return '';\n\n\t\t// translate those into numeric equivalents of the grid letters\n\t\tvar l1 = (19-n100k) - (19-n100k)%5 + Math.floor((e100k+10)/5);\n\t\tvar l2 = (19-n100k)*5%25 + e100k%5;\n\n\t\t// compensate for skipped 'I' and build grid letter-pairs\n\t\tif (l1 > 7) l1++;\n\t\tif (l2 > 7) l2++;\n\t\tvar letPair = String.fromCharCode(l1+'A'.charCodeAt(0), l2+'A'.charCodeAt(0));\n\n\t\t// strip 100km-grid indices from easting & northing, and reduce precision\n\t\te = Math.floor((e%100000)/Math.pow(10, 5-digits/2));\n\t\tn = Math.floor((n%100000)/Math.pow(10, 5-digits/2));\n\n\t\tvar gridRef = letPair + ' ' + pad(e, digits/2) + ' ' + pad(n, digits/2);\n\n\t\treturn gridRef;\n\t},\n\n\tosgbToLngLat: function(eastings, northings) {\n\t\tvar out = osgbProj.inverse([eastings, northings]);//to WSG84\n\t\treturn out;\n\t},\n\t\n\tgridRefToOsgb: function(/*String*/ gridref) {\n\t\tgridref = String(gridref).trim();\n\t\tthis._determineGridRefType(gridref);\n\n\t\t// check for fully numeric comma-separated gridref format\n\t\tvar match = gridref.match(/^(\\d+),\\s*(\\d+)$/);\n\t\tif (match) return new OsGridRef(match[1], match[2]);\n\n\t\t// validate format\n\t\tmatch = gridref.match(/^[A-Z]{2}\\s*[0-9]+\\s*[0-9]+$/i);\n\t\tif (!match) throw new Error('Invalid grid reference: ' + gridref);\n\n\t\t// get numeric values of letter references, mapping A->0, B->1, C->2, etc:\n\t\tvar l1 = gridref.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);\n\t\tvar l2 = gridref.toUpperCase().charCodeAt(1) - 'A'.charCodeAt(0);\n\t\t// shuffle down letters after 'I' since 'I' is not used in grid:\n\t\tif (l1 > 7) l1--;\n\t\tif (l2 > 7) l2--;\n\n\t\t// convert grid letters into 100km-square indexes from false origin (grid square SV):\n\t\tvar e100km = ((l1-2)%5)*5 + (l2%5);\n\t\tvar n100km = (19-Math.floor(l1/5)*5) - Math.floor(l2/5);\n\n\t\t// skip grid letters to get numeric (easting/northing) part of ref\n\t\tvar en = gridref.slice(2).trim().split(/\\s+/);\n\t\t// if e/n not whitespace separated, split half way\n\t\tif (en.length == 1) en = [ en[0].slice(0, en[0].length/2), en[0].slice(en[0].length/2) ];\n\n\t\t//fix for grid refs technically part of the grid but outside of the uk\n\t\t//this helped to work this out: https://raw.githubusercontent.com/wu-lee/dinty/master/national-grid.png\n\t\tif (e100km >= 15) {\n\t\t\te100km -= 25\n\t\t}\n\t\tif (n100km > 20) {\n\t\t\tn100km -= 25\n\t\t}\n\n\t\t// validation\n\t\tif (e100km < -10 || n100km < -5)  throw new Error('Invalid grid reference: gridref='+gridref+', e100km='+e100km+', n100km='+n100km);\n\t\tif (en.length != 2) throw new Error('Invalid grid reference: ' + gridref);\n\t\tif (en[0].length != en[1].length) throw new Error('Invalid grid reference: ' + gridref);\n\n\t\t// standardise to 10-digit refs (metres)\n\t\ten[0] = (en[0]+'00000').slice(0, 5);\n\t\ten[1] = (en[1]+'00000').slice(0, 5);\n\n\t\tvar e = parseInt(e100km + '00000') + parseInt(en[0]);\n\t\tvar n = parseInt(n100km + '00000') + parseInt(en[1]);\n\n\t\treturn [e, n];\n\t},\n\n\tgridRefToLngLat: function(/*String*/ gridref) {\n\t\tvar lngLat = this.gridRefToOsgb(gridref);\n\t\tvar out = osgbProj.inverse(lngLat);//to WSG84\n\t\treturn out;\n\t},\n\t\n\t_determineGridRefType: function(gridref) {\n\t\tif (/^\\w\\s*\\d{3,}\\s*\\d{3,}$/.test(gridref)) {\n\t\t\tthrow new Error('Irish grid references currently unsupported: ' + gridref);\n\t\t}\n\t}\n};\n"],"sourceRoot":""}