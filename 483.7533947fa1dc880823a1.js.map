{"version":3,"file":"483.7533947fa1dc880823a1.js","mappings":"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","sources":["webpack://@tstibbs/geo-bagging-ui/./src/js/conversion.js","webpack://@tstibbs/geo-bagging-ui/./test/conversion_test.js"],"sourcesContent":["//heavily borrowed from www.movable-type.co.uk/scripts/latlong-gridref.html (MIT licence)\nimport proj4 from 'proj4'\n\nvar osgbProj = proj4(\n\t'+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs'\n)\n\nfunction pad(num, w) {\n\tvar n = num.toString()\n\twhile (n.length < w) n = '0' + n\n\treturn n\n}\n\nexport default {\n\tlatLngToGridRef: function (lat, lng) {\n\t\tvar digits = 10\n\n\t\tvar out = osgbProj.forward([lng, lat]) //from WSG84\n\t\tvar eastings = out[0]\n\t\tvar northings = out[1]\n\n\t\tdigits = digits === undefined ? 10 : Number(digits)\n\t\tif (isNaN(digits)) throw new Error('Invalid precision')\n\n\t\tvar e = Number(Number(eastings))\n\t\tvar n = Number(Number(northings))\n\n\t\tif (isNaN(e) || isNaN(n)) throw new Error('Invalid grid reference: ' + [lat, lng])\n\n\t\t// use digits = 0 to return numeric format (in metres)\n\t\tif (digits === 0) return pad(e, 6) + ',' + pad(n, 6)\n\n\t\t// get the 100km-grid indices\n\t\tvar e100k = Math.floor(e / 100000),\n\t\t\tn100k = Math.floor(n / 100000)\n\n\t\tif (e100k < 0 || e100k > 6 || n100k < 0 || n100k > 12) return ''\n\n\t\t// translate those into numeric equivalents of the grid letters\n\t\tvar l1 = 19 - n100k - ((19 - n100k) % 5) + Math.floor((e100k + 10) / 5)\n\t\tvar l2 = (((19 - n100k) * 5) % 25) + (e100k % 5)\n\n\t\t// compensate for skipped 'I' and build grid letter-pairs\n\t\tif (l1 > 7) l1++\n\t\tif (l2 > 7) l2++\n\t\tvar letPair = String.fromCharCode(l1 + 'A'.charCodeAt(0), l2 + 'A'.charCodeAt(0))\n\n\t\t// strip 100km-grid indices from easting & northing, and reduce precision\n\t\te = Math.floor((e % 100000) / Math.pow(10, 5 - digits / 2))\n\t\tn = Math.floor((n % 100000) / Math.pow(10, 5 - digits / 2))\n\n\t\tvar gridRef = letPair + ' ' + pad(e, digits / 2) + ' ' + pad(n, digits / 2)\n\n\t\treturn gridRef\n\t},\n\n\tosgbToLngLat: function (eastings, northings) {\n\t\tvar out = osgbProj.inverse([eastings, northings]) //to WSG84\n\t\treturn out\n\t},\n\n\tgridRefToOsgb: function (/*String*/ gridref) {\n\t\tgridref = String(gridref).trim()\n\t\tthis._determineGridRefType(gridref)\n\n\t\t// check for fully numeric comma-separated gridref format\n\t\tvar match = gridref.match(/^(\\d+),\\s*(\\d+)$/)\n\t\tif (match) return new OsGridRef(match[1], match[2])\n\n\t\t// validate format\n\t\tmatch = gridref.match(/^[A-Z]{2}\\s*[0-9]+\\s*[0-9]+$/i)\n\t\tif (!match) throw new Error('Invalid grid reference: ' + gridref)\n\n\t\t// get numeric values of letter references, mapping A->0, B->1, C->2, etc:\n\t\tvar l1 = gridref.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0)\n\t\tvar l2 = gridref.toUpperCase().charCodeAt(1) - 'A'.charCodeAt(0)\n\t\t// shuffle down letters after 'I' since 'I' is not used in grid:\n\t\tif (l1 > 7) l1--\n\t\tif (l2 > 7) l2--\n\n\t\t// convert grid letters into 100km-square indexes from false origin (grid square SV):\n\t\tvar e100km = ((l1 - 2) % 5) * 5 + (l2 % 5)\n\t\tvar n100km = 19 - Math.floor(l1 / 5) * 5 - Math.floor(l2 / 5)\n\n\t\t// skip grid letters to get numeric (easting/northing) part of ref\n\t\tvar en = gridref.slice(2).trim().split(/\\s+/)\n\t\t// if e/n not whitespace separated, split half way\n\t\tif (en.length == 1) en = [en[0].slice(0, en[0].length / 2), en[0].slice(en[0].length / 2)]\n\n\t\t//fix for grid refs technically part of the grid but outside of the uk\n\t\t//this helped to work this out: https://raw.githubusercontent.com/wu-lee/dinty/master/national-grid.png\n\t\tif (e100km >= 15) {\n\t\t\te100km -= 25\n\t\t}\n\t\tif (n100km > 20) {\n\t\t\tn100km -= 25\n\t\t}\n\n\t\t// validation\n\t\tif (e100km < -10 || n100km < -5)\n\t\t\tthrow new Error('Invalid grid reference: gridref=' + gridref + ', e100km=' + e100km + ', n100km=' + n100km)\n\t\tif (en.length != 2) throw new Error('Invalid grid reference: ' + gridref)\n\t\tif (en[0].length != en[1].length) throw new Error('Invalid grid reference: ' + gridref)\n\n\t\t// standardise to 10-digit refs (metres)\n\t\ten[0] = (en[0] + '00000').slice(0, 5)\n\t\ten[1] = (en[1] + '00000').slice(0, 5)\n\n\t\tvar e = parseInt(e100km + '00000') + parseInt(en[0])\n\t\tvar n = parseInt(n100km + '00000') + parseInt(en[1])\n\n\t\treturn [e, n]\n\t},\n\n\tgridRefToLngLat: function (/*String*/ gridref) {\n\t\tvar lngLat = this.gridRefToOsgb(gridref)\n\t\tvar out = osgbProj.inverse(lngLat) //to WSG84\n\t\treturn out\n\t},\n\n\t_determineGridRefType: function (gridref) {\n\t\tif (/^\\w\\s*\\d{3,}\\s*\\d{3,}$/.test(gridref)) {\n\t\t\tthrow new Error('Irish grid references currently unsupported: ' + gridref)\n\t\t}\n\t}\n}\n","import {assert} from 'chai'\n\nimport conversion from '../src/js/conversion.js'\n\ndescribe('conversion', function () {\n\tit('latLngToGridRef - should return actual grid refs', function () {\n\t\tassert.equal(conversion.latLngToGridRef(52.657977, 1.716038), 'TG 51408 13177')\n\t})\n\n\tit('osgbToLngLat - should work for valid OSBGs', function () {\n\t\tvar actualValue = conversion.osgbToLngLat(651409, 313177) // array is long, lat\n\t\tassert.equal(actualValue.length, 2)\n\t\tassertNear(assert, actualValue[0], 1.7160384428258, 0)\n\t\tassertNear(assert, actualValue[1], 52.657976601295, 0)\n\t})\n\n\tit('gridRefToOsgb - should work for valid grid refs', function () {\n\t\tassert.deepEqual(conversion.gridRefToOsgb('TG 51408 13177'), [651408, 313177]) // array is long, lat\n\t})\n\tit('gridRefToOsgb - should work for channel islands', function () {\n\t\tassert.deepEqual(conversion.gridRefToOsgb('XD  83873  22339'), [383873, -77661]) // array is long, lat\n\t})\n\n\tit('gridRefToLngLat - should work for valid grid refs', function () {\n\t\tassertCloseEnough(assert, 'TG 51408 13177', 1.716023690108, 52.657977064472, 0)\n\t})\n\n\tit('gridRefToOsgb - should error for irish grids', function () {\n\t\tassert.throws(function () {\n\t\t\tconversion.gridRefToOsgb('S  6797  3789')\n\t\t}, /Irish/)\n\t\tassert.throws(function () {\n\t\t\tconversion.gridRefToOsgb('W328850')\n\t\t}, /Irish/)\n\t})\n\n\tit('gridRefToLngLat - should work for ireland and channel islands', function () {\n\t\tassertCloseEnough(assert, 'MZ 82568 85820', -8.53034, 54.99125, 0.00002)\n\t\tassertCloseEnough(assert, 'MZ 86383 16308', -8.37269, 54.37367, 0.00002)\n\t\tassertCloseEnough(assert, 'RE 09504 80322', -9.48801, 53.98501, 0.00002)\n\t\tassertCloseEnough(assert, 'RO 61800 27500', -9.79229, 51.68706, 0.00002)\n\t\tassertCloseEnough(assert, 'WA 55943 05921', -13.43272, 48.48317, 0.0001) //there's a different ellipsis that we need to use for the channel islands, but this is close enough for now\n\t\tassertCloseEnough(assert, 'WA 57817 06737', -13.40949, 48.49285, 0.0001) //there's a different ellipsis that we need to use for the channel islands, but this is close enough for now\n\t})\n})\n\nfunction assertCloseEnough(assert, gridRef, lon, lat, leeway) {\n\tvar actualValue = conversion.gridRefToLngLat(gridRef) // array is long, lat\n\tassert.equal(actualValue.length, 2)\n\tassertNear(assert, actualValue[0], lon, leeway)\n\tassertNear(assert, actualValue[1], lat, leeway)\n}\n\n// The exact results seem to change slightly from browser to browser, and even between different versions of node.\n// However, the 5th decimal place is about 1 metre at our latitude/longitude, so we _really_ don't need to care about small differences\nfunction assertNear(assert, actual, expected, leeway) {\n\tvar rounder = 100000\n\tvar lower = Math.floor(expected * rounder) / rounder\n\tvar upper = Math.ceil(expected * rounder) / rounder\n\tlower -= leeway\n\tupper += leeway\n\n\tassert.ok(actual >= lower, actual + ' should be >= ' + lower)\n\tassert.ok(actual <= upper, actual + ' should be <= ' + upper)\n}\n"],"names":["osgbProj","pad","num","w","n","toString","length","latLngToGridRef","lat","lng","digits","out","forward","eastings","northings","undefined","Number","isNaN","Error","e","e100k","Math","floor","n100k","l1","l2","letPair","String","fromCharCode","charCodeAt","pow","osgbToLngLat","inverse","gridRefToOsgb","gridref","trim","this","_determineGridRefType","match","OsGridRef","toUpperCase","e100km","n100km","en","slice","split","parseInt","gridRefToLngLat","lngLat","test","assertCloseEnough","assert","gridRef","lon","leeway","actualValue","equal","assertNear","actual","expected","rounder","lower","upper","ceil","ok","describe","it"],"sourceRoot":""}